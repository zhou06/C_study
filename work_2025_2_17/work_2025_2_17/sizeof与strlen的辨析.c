#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
// sizeof
// 1. sizeof是操作符
// 2. sizeof计算操作数所占内存的??，单位是字节
// 3. 不关注内存中存放什么数据
// strlen
// 1. strlen是库函数，使?需要包含头?件 string.h
// 2. srtlen是求字符串?度的，统计的是 \0 之前字符的个数
// 3. 关注内存中是否有 \0 ，如果没有 \0 ，就会持续往后找，可能会越界
// 1.sizeof(数组名)，这⾥的数组名表示整个数组，计算的是整个数组的⼤⼩。
// 2. & 数组名，这⾥的数组名表⽰整个数组，取出的是整个数组的地址。
// 3. 除此之外所有的数组名都表示⾸元素的地址

int main()
{
	// 一维数组
	int a[] = { 1,2,3,4 };
	printf("%zd\n", sizeof(a));	// a此处为整个数组地址，计算的是整个数组的字节长->16
	printf("%zd\n", sizeof(a + 0));	// 这里a为首元素地址，a+0还是地址，计算的是地址字节->4/8
	printf("%zd\n", sizeof(*a));	// a就是首元素的地址,*a就是首元素.计算的是首元素的大小:4个字节
	printf("%zd\n", sizeof(a + 1));// a就是首元素的地址,a+1是第二个元素的地址,计算的是地址的大小: 4 / 8
	printf("%zd\n", sizeof(a[1]));// 计算的是第二个元素的大小,4
	printf("%zd\n", sizeof(&a));// &a - 取出的是数组的地址. 是地址都是4/8个字节
	printf("%zd\n", sizeof(*&a));// *&a, * 和 &抵消了,sizeof(a)，16
	printf("%zd\n", sizeof(&a + 1));// &a+1是跳过整个数组,指向4的后面,其实也是地址,是地址就是4/8个字节
	printf("%zd\n", sizeof(&a[0]));// &a[0]就是首元素的地址,4 / 8 个字节
	printf("%zd\n", sizeof(&a[0] + 1));// 指的是第二个元素的地址，4/8
	// 字符数组
	char arr1[] = { 'a','b','c','d','e','f' };
	printf("%zd\n", sizeof(arr1));// arr是数组名,单独放在sizeof内部.计算的是数组的大小 - 6
	printf("%zd\n", sizeof(arr1 + 0));// arr是数组名,是数组首元素的地址,arr+0也是数组首元素的地址,是地址就是4/8
	printf("%zd\n", sizeof(*arr1));// arr是数组首元素的地址,*arr就是首元素.大小是1个字节
	printf("%zd\n", sizeof(arr1[1]));// arr[1]是第二个元素,大小是1个字节
	printf("%zd\n", sizeof(&arr1));// &arr是数组的地址,数组的地址也是地址,大小是4/8个字节
	printf("%zd\n", sizeof(&arr1 + 1));// &arr是数组的地址,&arr+1就是跳过整个数组,指向了f的后面. 4/8个字节
	printf("%zd\n", sizeof(&arr1[0] + 1));// &arr[0] + 1是第二个元素的地址,大小就是4/8

	printf("%zd\n", strlen(arr1));//随机值;arr是首元素的地址,数组中没有\0,一直往后找,什么时候遇到\0不清楚
	printf("%zd\n", strlen(arr1 + 0));//随机值;arr是首元素的地址,arr+1依然是首元素的地址
	//printf("%zd\n", strlen(*arr1));//*arr是首元素,是'a' - 97,传给strlen函数,97会被当做地址.	以97作为地址,会形成非法访问,程序会崩溃
	//printf("%zd\n", strlen(arr1[1]));//arr[1]是第2个元素,就是'b' - 98,传给strlen函数,98会被当做地址.同上,程序崩溃
	printf("%zd\n", strlen(&arr1));//&arr是数组的地址,虽然是数组的地址,值和首元素的地址一样.strlen依然是从第一个字符的位置开始向后找\0,会得到随机值.
	printf("%zd\n", strlen(&arr1 + 1));//&arr + 1是f后面的地址,什么时候遇到\0,依然不知道.随机值.
	printf("%zd\n", strlen(&arr1[0] + 1));//&arr[0]+1就是第二个元素的地址,得到的也是随机值

	char arr2[] = "abcdef";	// 此处字符数组最后会补充一个自己补充\0

	printf("%zd\n", sizeof(arr2));//arr2表示整个数，计算的是整个数组的大小单位字节，7*1 = 7
	printf("%zd\n", sizeof(arr2 + 0));//arr2就是数组首元素的地址,arr2+0还是数组首元素的地址 4 / 8
	printf("%zd\n", sizeof(*arr2));//1,arr2就是数组首元素的地址,*arr2是首元素，大小就是1个字节
	printf("%zd\n", sizeof(arr2[1]));//arr2[1]数组的第二个元素，计算的就是第二个元素的大小，单位是字节 - 1
	printf("%zd\n", sizeof(&arr2));//arr2表示整个数组，&arr2取出的是整个数组的地址，是地址大小就是4/8个字节
	printf("%zd\n", sizeof(&arr2 + 1));//&arr2 + 1是跳过这个数组后的地址，是地址大小就是4/8个字节
	printf("%zd\n", sizeof(&arr2[0] + 1));//&arr2[0]是数组首元素的地址，&arr2[0]+1是数组第二个元素的地址：4 / 8
	
	printf("%d\n", strlen(arr2));// 6: arr是数组首元素的地址，从第一个元素开始，统计\0之前字符的个数
	printf("%d\n", strlen(arr2 + 0));// 6：arr是数组首元素的地址,arr+0还是数组首元素的地址，结果同上
	//printf("%d\n", strlen(*arr2));// arr是数组首元素的地址,*arr就是首元素了，*arr == 'a' == 97,非法访问
	//printf("%d\n", strlen(arr2[1]));// 同上，非法访问
	printf("%d\n", strlen(&arr2));// 6：&arr取出的是数组的地址,数组的地址和首元素的地址是同一个值
	printf("%d\n", strlen(&arr2 + 1));// 随机值
	printf("%d\n", strlen(&arr2[0] + 1)); // 5： & arr[0] + 1是第二个元素的地址，\0之前有5个元素

	const char* p = "abcdef";

	printf("%zd\n", sizeof(p));//4/8,p是一个指针变量，大小就是4/8个字节
	printf("%zd\n", sizeof(p + 1));//4/8,p中存放的是'a'的地址，p+1是'b'的地址,大小就是4/8个字节
	printf("%zd\n", sizeof(*p));//1: *p=='a'
	printf("%zd\n", sizeof(p[0]));//1：p[0]==*(p+0)==*p,结果就同上
	printf("%zd\n", sizeof(&p));//&p是指针变量p的地址,是地址大小就是4/8个字节
	printf("%zd\n", sizeof(&p + 1));//&p + 1还是地址大小是4/8个字节
	printf("%zd\n", sizeof(&p[0] + 1));//&p[0] + 1是'b'的地址，大小是4/8个字节

	printf("%zd\n", strlen(p));//6: p里边存放是'a'的地址
	printf("%zd\n", strlen(p + 1));//5: p+1是'b'的地址
	//printf("%zd\n", strlen(*p));//非法访问, *p是'a'
	//printf("%zd\n", strlen(p[0]));//非法访问,效果同上
	printf("%zd\n", strlen(&p));//随机值，&p是p这个变量的地址,strlen就是从p这块空间的起始地址开始向后找\0的，p中存放的地址是不确定的,所有有没有\0,什么时候会遇到\0都不确定
	printf("%zd\n", strlen(&p + 1));//随机值，&p+1是p变量后边的地址,从这个位置向后的内存数据不知道，什么时候会遇到\0都不确定
	printf("%zd\n", strlen(&p[0] + 1));//5：此处&p[0]+1指的是'b'的地址，从b往后到\0共有5个字符

	// 二维数组
	int b[3][4] = { 0 };
	printf("%zd\n", sizeof(b));//48: b是数组名,单独放在sizeof内部,表示整个数组,计算的是整个数组的大小,单位是字节3*4*4 = 48
	printf("%zd\n", sizeof(b[0][0]));//4: b[0][0]是第一行第一个元素
	printf("%zd\n", sizeof(b[0]));//16: b[0]是第一行这个一维数组的数组名,数组名单独放在sizeof内部,计算的是第一行这个一维数组的大小
	printf("%zd\n", sizeof(b[0] + 1));//4/8:b[0]是数组名,这里表示数组首元素的地址,是第一行第一个元素的地址,b[0] + 1就是第一行第二个元素的地址,是地址大小就是4/8
	printf("%zd\n", sizeof(*(b[0] + 1)));//*(b[0] + 1))是第一行第二个元素-大小是4个字节
	printf("%zd\n", sizeof(b + 1));//b+1就是第二行的地址,是地址就是4/8个字节,b是二维数组的数组名,在这里表示首元素的地址,也就是第一行的地址,b+1就是第二行的地址
	printf("%zd\n", sizeof(*(b + 1)));//16,a + 1是第二行的地址,*(a+1)得到的就是第二行
	//int(*)[4]         对数组指针解引用,放一个数组,就是一行的一维数组
	//*(a+1) == a[1], a[1]是第二行的数组名,sizeof(arr[1])计算的是第二行的大小
	printf("%zd\n", sizeof(&b[0] + 1));//4/8:b[0]是第一行的数组名,&b[0]取出的是第一行这个一维数组的地址,&b[0]+1就是第二行的地址
	printf("%zd\n", sizeof(*(&b[0] + 1)));//*(&b[0] + 1)是第二行,计算的是第二行的大小,16个字节
	printf("%zd\n", sizeof(*b));//16: b是二维数组的数组名,b是首元素的地址,就是第一行的地址,*b就是第一行
	//*b == *(b+0) == b[0]
	printf("%zd\n", sizeof(b[3]));//16: 没有越界访问,sizeof内部的表达式是不计算的.
	//sizeof(int) - 4
	//sizeof(4+3);--4

	// 指针运算笔试题解析
	// 题目1.
	int c[5] = { 1,2,3,4,5 };
	int* ptr = (int*)(&c + 1);
	printf("%d %d\n", *(c + 1), *(ptr - 1));	// 2 5
	// 题目2.
	// 在X86环境下
	// 假设结构体的大小是20个字节
	// 程序输出的结果是啥？
	struct Test
{
    int Num;	// 4字节
    char* pcName;	// 4(x86)/8(x64)
    short sDate;	// 2
    char cha[2];	// 2
    short sBa[4];	// 8
} * p1 = (struct Test*)0x100000;	// p初始化为0x100000

    printf("%p\n", p1 + 0x1);	// p + 1步长为结构体大小20字节 0x100000+20 = 0x100000 + 0x14 = 0x100014
    printf("%p\n", (unsigned long)p1 + 0x1);//这里是不是指针+1 ? 不是.其实是整数+1
    //0x100000+1 --> 0x100001
    printf("%p\n", (unsigned int*)p1 + 0x1);//0x100004
    
	// 题目3.
	int d[3][2] = { (0,1),(2,3),(4,5) };	// 初始化错误，里面各个括号变成了整个的逗号表达式，第一个结果是1,第二个是3,第三个是5，所以该二维数组实际存储的是1,3,5,0,0,0
	// 正确的初始化应该是用{}括起每行结果
	int* p2;
	p2 = d[0];
	printf("%d\n", p2[0]);	// 根据上面的描述，此处结果应为1

	// 题目4.
	//假设环境是x86环境，程序输出的结果是啥？
	int e[5][5];
	int(*p3)[4];
	p3 = e;
	printf("%p,%d\n", &p3[4][2] - &e[4][2], &p3[4][2] - &e[4][2]);	
	// 指针-指针的前提是两个指针指向同一快空间
	// 指针-指针得到的结果的绝对值是两个指针之间的元素个数
	// &p3[4][2] 与 &e[4][2]相隔4个整数，由于地址从低到高，此处为小地址减去大地址
	// 结果应为-4，但是用地址打印应该先将-4对应的二进制数转换为对应补码再转换为十六进制
	// 10000000 00000000 00000000 00000100		-4
	// 11111111 11111111 11111111 11111011		反码
	// 11111111 11111111 11111111 11111100		补码
	// FF		FF		 FF		  FC            对应十六进制
	// 所以结果为FFFFFFFC,-4

	// 题目5.
	int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int* ptr1 = (int*)(&aa + 1);	
	int* ptr2 = (int*)(*(aa + 1));
	printf("%d,%d\n", *(ptr1 - 1), *(ptr2 - 1));	// 10,5

	// 题目6.
	char* f[] = { "work","at","alibaba" };
	char** pa = f;
	pa++;
	printf("%s\n", *pa);	// 打印出at

	// 题目7.
	char* g[] = { "ENTER","NEW","POINT","FIRST" };
	char** gp[] = { g + 3,g + 2,g + 1,g };	// g+3对应"FIRST",g+2"POINT","NEW","ENTER"
	char*** gpp = gp;	// 对应gp首元素即"FIRST"
	printf("%s\n", **++gpp);// POINT:先进行自增，gpp先对应变成gp+1,也就是g+2的地址对应"POINT"，两次解引用得到了"POINT"中P的地址，打印到\0出现得到POINT
	printf("%s\n", *-- * ++gpp + 3);// ER:
	// gpp再进行自增，对应gp+2,也就是g+1的地址，然后再对此时的gpp进行解引用
	// 此时式子变为*--(gp[2]),注意此处是将*++gpp进行运算，得到的gp[2]，他还是一个指针，所以对他进行了--并再次解引用
	// 这会导致gp数组中第三个元素g+1减一，也就是说这一步实质是把gp[2]变为了g，再进行解引用得到了"ENTER"中第一个E的地址
	// +3后变为第二个E地址，打印到\0出现，所以得到ER
	printf("%s\n", *gpp[-2] + 3);// ST：
	// 此处gpp[-2] 实质上是*(gpp-2),所以这里可以转化为*(*(gpp-2)) + 3
	// gpp此时为gp[2]的地址，减二重新变为gp[0]的地址，解引用两次得到"FIRST"中F的地址，再加三得到S的地址，打印得到ST
	printf("%s\n", gpp[-1][-1] + 1);// EW：
	// 同上，先进行简化得到*(*(gpp-1)-1)+1，和前两个式子不同，第三个式子并未实际改变gpp的指向
	// 所以此处gpp仍然对应gp[2],减一后解引用得到的是g+2的地址，
	// 再减一得到g+1的地址，再进行解引用得到的是"NEW"中N的地址
	// 最后再加一得到E的地址，打印输出EW
	return 0;
}